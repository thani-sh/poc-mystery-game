# ADR-002: Project Architecture and Structure

Date: 2025-12-09

## Status

Accepted

## Context

The PixiJS Creation Template provides a base structure, but we need to define how we'll organize code for a JRPG game with specific requirements:
- Turn-based tactical combat on a grid
- Overworld exploration
- Character management
- Multiple game screens (title, menu, battle, exploration)
- Save/load system
- Dialogue system
- Item and inventory management

## Decision

We will extend the Creation Template's architecture with a layered structure optimized for JRPG development:

### Directory Structure

```
src/
├── engine/              # Core engine systems (from template)
│   ├── audio/          # Audio management
│   ├── navigation/     # Screen/popup navigation
│   ├── resize/         # Responsive resize handling
│   └── utils/          # Engine utilities
├── app/
│   ├── screens/        # Full-screen views
│   │   ├── LoadScreen.ts
│   │   ├── TitleScreen.ts      # [TO ADD]
│   │   ├── BattleScreen.ts     # [TO ADD]
│   │   └── ExplorationScreen.ts # [TO ADD]
│   ├── popups/         # Modal overlays
│   │   ├── PausePopup.ts
│   │   ├── SettingsPopup.ts
│   │   └── MenuPopup.ts        # [TO ADD]
│   ├── ui/             # Reusable UI components
│   │   └── Button.ts
│   └── utils/          # App utilities
├── game/               # [TO ADD] Game-specific logic
│   ├── entities/       # Game entities (characters, items)
│   ├── systems/        # Game systems (combat, movement, inventory)
│   ├── grid/           # Grid and tile system
│   ├── data/           # Game data definitions
│   └── ai/             # AI for enemies
└── main.ts             # Application entry point
```

### Architecture Layers

1. **Engine Layer** (`src/engine/`)
   - Handles low-level PixiJS integration
   - Manages application lifecycle
   - Provides navigation, audio, and resize services
   - Template-provided, minimal customization needed

2. **App Layer** (`src/app/`)
   - Screens and UI components
   - Visual presentation logic
   - User interaction handling
   - Bridges game logic with rendering

3. **Game Layer** (`src/game/`) [TO BE IMPLEMENTED]
   - Pure game logic (entity management, combat rules)
   - Should be largely render-agnostic
   - Contains game state and systems
   - Can be unit tested independently

### Key Patterns

**Screen Lifecycle:**
- Each screen extends `Container`
- Implements lifecycle methods: `prepare()`, `show()`, `hide()`, `resize()`, `update()`
- Can pause/resume when popups are shown
- Declares required asset bundles

**Asset Management:**
- Uses AssetPack for optimization
- Raw assets in `raw-assets/`
- Processed assets output to `public/assets/`
- Assets loaded by bundle (preload, main, etc.)
- Manifest auto-generated by AssetPack

**State Management:**
- No global state framework initially (keep it simple)
- Screens own their state
- Shared state in service classes (e.g., `GameState`, `PlayerData`)
- Will evaluate Redux/MobX if complexity grows

**Entity-Component Pattern:**
- Game entities are data objects
- Systems process entities (combat system, movement system)
- View components render entities (sprite representation)
- Separation between logic and rendering

## Consequences

### Positive
- Clear separation of concerns (engine, app, game)
- Screens are self-contained and easy to test
- Game logic can be unit tested without rendering
- Easy to add new screens and popups
- Asset pipeline is optimized out of the box
- Hot reload works well with screen-based architecture

### Negative
- Additional layer of abstraction beyond template
- Need to build game systems from scratch
- Communication between layers requires careful design
- May need refactoring as game complexity grows

### Neutral
- Will need to define game data schema
- State management approach may evolve
- Asset organization needs discipline
